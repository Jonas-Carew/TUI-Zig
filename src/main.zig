const std = @import("std");
const vaxis = @import("vaxis");

/// Set the default panic handler to the vaxis panic_handler. This will clean up the terminal if any
/// panics occur
pub const panic = vaxis.panic_handler;

/// Set some scope levels for the vaxis scopes
pub const std_options: std.Options = .{
    .log_scope_levels = &.{
        .{ .scope = .vaxis, .level = .warn },
        .{ .scope = .vaxis_parser, .level = .warn },
    },
};

/// Tagged union of all events our application will handle. These can be generated by Vaxis or your
/// own custom events
const Event = union(enum) {
    key_press: vaxis.Key,
    key_release: vaxis.Key,
    mouse: vaxis.Mouse,
    focus_in, // window has gained focus
    focus_out, // window has lost focus
    paste_start, // bracketed paste start
    paste_end, // bracketed paste end
    paste: []const u8, // osc 52 paste, caller must free
    color_report: vaxis.Color.Report, // osc 4, 10, 11, 12 response
    color_scheme: vaxis.Color.Scheme, // light / dark OS theme changes
    winsize: vaxis.Winsize, // the window size has changed. This event is always sent when the loop
    // is started
};

const State = enum { Child, Tiles, Battle, Boxes, Cards };

const BattleState = enum { Attack };
const Cell = enum { empty, box };
const Pos = struct {
    x: usize,
    y: usize,
    inv: bool = false, // handles negative values, only for shift
};
const Suit = enum { heart, diamond, spade, club };
const CardVal = enum { A, @"2", @"3", @"4", @"5", @"6", @"7", @"8", @"9", @"10", J, Q, K };
const Card = struct {
    suit: Suit,
    value: CardVal,
    up: bool = false,
};
const CardMenu = enum { symbols, pull3, start };

/// The application state
const MyApp = struct {
    allocator: std.mem.Allocator,
    // A flag for if we should quit
    should_quit: bool,
    /// The tty we are talking to
    tty: vaxis.Tty,
    /// The vaxis instance
    vx: vaxis.Vaxis,
    /// A mouse event that we will handle in the draw cycle
    mouse: ?vaxis.Mouse,

    /// A struct with all app variables
    app: struct {
        menu: struct {
            active: bool = false,
            state: State = .Child,
        } = .{},

        state: union(State) {
            Child: struct {
                state: enum { hello, goodbye } = .hello,

                color: struct {
                    r: bool = true,
                    g: bool = true,
                    b: bool = true,
                } = .{},
                hovered: bool = false,
                clicked: bool = false,
            },

            Tiles: struct {
                state: enum { selection, tiles } = .selection,

                uni: ?vaxis.Unicode = null,
                input: ?vaxis.widgets.TextInput = null,

                height: ?usize = null,
                height_text: ?[]const u8 = null,
                width: ?usize = null,
                width_text: ?[]const u8 = null,

                colors: ?[][]vaxis.Color = null,
            },

            Battle: struct {
                const Attack = struct {
                    name: []const u8,
                    damage: u32,
                };

                state: union(enum) {
                    main: struct {
                        state: BattleState = .Attack,
                    },
                    attack: struct {
                        num: u4 = 0,
                    },
                } = .{ .main = .{} },

                attacks: [4]?Attack = .{ null, null, null, null },
                len: u4 = 0,
            },

            Boxes: struct {
                pub fn shift(self: *@This(), pos: Pos, mov: Pos) bool {
                    // out of bounds
                    if (!mov.inv) {
                        if ((pos.y + mov.y < 0) or (pos.y + mov.y >= self.field.len) or
                            (pos.x + mov.x < 0) or (pos.x + mov.x >= self.field[0].len))
                            return false;
                    } else {
                        if ((pos.y < mov.y) or (pos.y >= mov.y + self.field.len) or
                            (pos.x < mov.x) or (pos.x >= mov.x + self.field[0].len))
                            return false;
                    }
                    const end: Pos = if (!mov.inv) .{ .x = pos.x + mov.x, .y = pos.y + mov.y } else blk: {
                        break :blk .{ .x = pos.x - mov.x, .y = pos.y - mov.y };
                    };

                    switch (self.field[end.y][end.x]) {
                        // empty is movement
                        .empty => {
                            self.field[end.y][end.x] = self.field[pos.y][pos.x];
                            self.field[pos.y][pos.x] = .empty;
                            return true;
                        },
                        .box => {
                            if (self.shift(end, mov)) {
                                self.field[end.y][end.x] = self.field[pos.y][pos.x];
                                self.field[pos.y][pos.x] = .empty;
                                return true;
                            } else return false;
                        },
                    }
                }

                field: [9][9]Cell = [1][9]Cell{
                    [1]Cell{.empty} ** 9,
                } ** 9,
                pos: Pos = .{ .x = 0, .y = 0 },
            },

            Cards: struct {
                pub fn shuffle(self: *@This()) !void {
                    for (0..self.deck.len) |i| {
                        self.deck[i] = Card{
                            .suit = @enumFromInt(i % 4),
                            .value = @enumFromInt(i % 13),
                        };
                    }

                    var seed: u64 = 0;
                    try std.posix.getrandom(std.mem.asBytes(&seed));
                    var prng = std.rand.DefaultPrng.init(seed);
                    const rand = prng.random();

                    var newDeck: [52]Card = [1]Card{undefined} ** 52;

                    for (0..newDeck.len) |i| {
                        const end: usize = self.deck.len - i;
                        const pos = rand.int(usize) % end;
                        newDeck[i] = self.deck[pos];
                        self.deck[pos] = self.deck[end - 1];
                    }

                    self.deck = newDeck;
                    self.place = 0;
                }

                pub fn getCard(self: *@This()) !Card {
                    if (self.place < 52) {
                        defer self.place += 1;
                        return self.deck[self.place];
                    }
                    return error.DeckEmpty;
                }

                pub fn pullOne(self: *@This()) !void {
                    if (self.stack[0]) |card0| {
                        if (!card0.up) {
                            blk: {
                                var iter: usize = 1;
                                while (self.stack[iter]) |card| : (iter += 1) {
                                    if (card.up) break;
                                    if (iter == self.stack.len - 1) {
                                        self.stack[iter].?.up = true;
                                        break :blk;
                                    }
                                }
                                self.stack[iter - 1].?.up = true;
                            }
                        } else return error.StackFullyDrawn;
                    } else return error.StackEmpty;
                }

                pub fn pullStack(self: *@This()) !void {
                    const rep: usize = if (self.opts.pull3) 3 else 1;
                    for (0..rep) |_| {
                        self.pullOne() catch |err|
                            if (rep == 0) return err;
                        // return the first one - that is pulling an empty/drawn stack
                        // dont return 2 or 3, that is a fine scenario
                    }
                }

                pub fn flipStack(self: *@This()) void {
                    for (self.stack, 0..) |card, i| {
                        if (card) |_|
                            self.stack[i].?.up = false;
                    }
                }

                pub fn popStack(self: *@This()) !void {
                    for (self.stack, 0..) |_card, bp| {
                        if (_card) |card| {
                            if (card.up) {
                                for (bp..(self.stack.len - 1)) |i| {
                                    self.stack[i] = self.stack[i + 1];
                                }
                                self.stack[self.stack.len - 1] = null;
                                return;
                            }
                        } else return error.StackNotDrawn;
                    }
                    return error.StackNotDrawn;
                }

                deck: [52]Card = [1]Card{undefined} ** 52,
                place: usize = 0,

                field: [7][19]?Card = [_][19]?Card{[_]?Card{null} ** 19} ** 7,
                // 19 for 6 unturned cards + a full stack K-A
                acePiles: [4][13]?Card = [_][13]?Card{[_]?Card{null} ** 13} ** 4,
                stack: [24]?Card = [_]?Card{null} ** 24,

                select: union(enum) {
                    stack,
                    ace: u2,
                    field,
                } = .field,
                pos: Pos = .{ .x = 0, .y = 0 },
                move: Pos = .{ .x = 0, .y = 0 },
                mode: enum { select, move } = .select,

                card: ?Card = null,

                win: bool = false,
                numWins: u8 = 0,
                winStr: []u8 = "",

                opts: struct {
                    menu: bool = true,
                    select: CardMenu = .symbols,
                    symbols: bool = false,
                    pull3: bool = true,
                } = .{},
            },
        } = .{ .Child = .{} },
    } = .{},

    pub fn init(allocator: std.mem.Allocator) !MyApp {
        return .{
            .allocator = allocator,
            .should_quit = false,
            .tty = try vaxis.Tty.init(),
            .vx = try vaxis.init(allocator, .{}),
            .mouse = null,
        };
    }

    pub fn deinit(self: *MyApp) void {
        // Deinit takes an optional allocator. You can choose to pass an allocator to clean up
        // memory, or pass null if your application is shutting down and let the OS clean up the
        // memory

        self.vx.deinit(self.allocator, self.tty.anyWriter());
        self.tty.deinit();

        if (self.app.state == .Tiles) self.detiles();
    }

    pub fn detiles(self: *MyApp) void {
        switch (self.app.state) {
            .Tiles => |*Tiles| {
                if (Tiles.input) |*input| input.*.deinit();
                if (Tiles.uni) |uni| uni.deinit();

                if (Tiles.height_text) |htext| self.allocator.free(htext);
                if (Tiles.width_text) |wtext| self.allocator.free(wtext);

                if (Tiles.colors) |colors| {
                    for (colors) |row| {
                        self.allocator.free(row);
                    }
                    self.allocator.free(colors);
                }
            },
            else => unreachable,
        }
    }

    pub fn run(self: *MyApp) !void {
        // Initialize our event loop. This particular loop requires intrusive init
        var loop: vaxis.Loop(Event) = .{
            .tty = &self.tty,
            .vaxis = &self.vx,
        };
        try loop.init();

        // Start the event loop. Events will now be queued
        try loop.start();

        try self.vx.enterAltScreen(self.tty.anyWriter());

        // Query the terminal to detect advanced features, such as kitty keyboard protocol, etc.
        // This will automatically enable the features in the screen you are in, so you will want to
        // call it after entering the alt screen if you are a full screen application. The second
        // arg is a timeout for the terminal to send responses. Typically the response will be very
        // fast, however it could be slow on ssh connections.
        try self.vx.queryTerminal(self.tty.anyWriter(), 1 * std.time.ns_per_s);

        // Enable mouse events
        try self.vx.setMouseMode(self.tty.anyWriter(), true);

        // This is the main event loop. The basic structure is
        // 1. Handle events
        // 2. Draw application
        // 3. Render
        while (!self.should_quit) {
            // pollEvent blocks until we have an event
            loop.pollEvent();
            // tryEvent returns events until the queue is empty
            while (loop.tryEvent()) |event| {
                try self.update(event);
            }
            // Draw our application after handling events
            self.draw();

            // It's best to use a buffered writer for the render method. TTY provides one, but you
            // may use your own. The provided bufferedWriter has a buffer size of 4096
            var buffered = self.tty.bufferedWriter();
            // Render the application to the screen
            try self.vx.render(buffered.writer().any());
            try buffered.flush();
        }
    }

    /// Update our application state from an event
    pub fn update(self: *MyApp, event: Event) !void {
        // universal events
        switch (event) {
            .key_press => |key| {
                if (key.matches('c', .{ .ctrl = true })) {
                    self.should_quit = true;
                    return;
                }
            },
            .mouse => |mouse| self.mouse = mouse,
            .winsize => |ws| try self.vx.resize(self.allocator, self.tty.anyWriter(), ws),
            else => {},
        }
        // no event handling while in the menu
        if (!self.app.menu.active) {
            switch (event) {
                .key_press => |key| {
                    if (key.matches(vaxis.Key.escape, .{})) {
                        self.app.menu.active = true;
                    }
                },
                else => {},
            }
        } else {
            switch (event) {
                .key_press => |key| {
                    const len = @typeInfo(State).Enum.fields.len;
                    const int = @intFromEnum(self.app.menu.state);
                    const cp0 = 48; // codepoint of 0

                    if (key.matches(vaxis.Key.escape, .{})) {
                        self.app.menu.active = false;
                        self.app.menu.state = self.app.state;
                    }
                    if (key.matches(vaxis.Key.up, .{}) and (int > 0)) {
                        self.app.menu.state = @enumFromInt((int + len - 1) % len);
                    }
                    if (key.matches(vaxis.Key.down, .{}) and (int < len - 1)) {
                        self.app.menu.state = @enumFromInt((int + 1) % len);
                    }
                    if ((key.codepoint > cp0) and (key.codepoint <= cp0 + len)) {
                        self.app.menu.state = @enumFromInt(key.codepoint - cp0 - 1);
                    }
                    if (key.matches(vaxis.Key.enter, .{})) {
                        if (self.app.state == .Tiles) self.detiles();
                        switch (self.app.menu.state) {
                            .Child => {
                                self.app.state = .{ .Child = .{} };
                            },
                            .Tiles => {
                                self.app.state = .{ .Tiles = .{} };
                                switch (self.app.state) {
                                    .Tiles => |*Tiles| {
                                        Tiles.uni = try vaxis.Unicode.init(self.allocator);
                                        Tiles.input = vaxis.widgets.TextInput.init(
                                            self.allocator,
                                            &Tiles.uni.?,
                                        );
                                    },
                                    else => unreachable,
                                }
                            },
                            .Battle => {
                                self.app.state = .{ .Battle = .{} };
                                switch (self.app.state) {
                                    .Battle => |*Battle| {
                                        Battle.attacks[0] = .{
                                            .name = "Slash",
                                            .damage = 5,
                                        };
                                        Battle.attacks[1] = .{
                                            .name = "Magic Missile",
                                            .damage = 10,
                                        };
                                        Battle.attacks[2] = .{
                                            .name = "Fireball",
                                            .damage = 50,
                                        };
                                        Battle.len = 3;
                                    },
                                    else => unreachable,
                                }
                            },
                            .Boxes => {
                                self.app.state = .{ .Boxes = .{} };
                                switch (self.app.state) {
                                    .Boxes => |*Boxes| {
                                        Boxes.field = [9][9]Cell{
                                            [1]Cell{.empty} ** 9,
                                            [1]Cell{.empty} ** 9,
                                            [9]Cell{ .empty, .empty, .empty, .empty, .box, .empty, .empty, .empty, .empty },
                                            [1]Cell{.empty} ** 9,
                                            [9]Cell{ .empty, .empty, .box, .empty, .empty, .empty, .box, .empty, .empty },
                                            [1]Cell{.empty} ** 9,
                                            [9]Cell{ .empty, .empty, .empty, .empty, .box, .empty, .empty, .empty, .empty },
                                            [1]Cell{.empty} ** 9,
                                            [1]Cell{.empty} ** 9,
                                        };
                                        Boxes.pos = .{ .x = 4, .y = 4 };
                                    },
                                    else => unreachable,
                                }
                            },
                            .Cards => {
                                self.app.state = .{ .Cards = .{} };
                                switch (self.app.state) {
                                    .Cards => |*Cards| {
                                        try Cards.shuffle();
                                        for (0..7) |col| {
                                            for (0..(col + 1)) |row| {
                                                Cards.field[col][row] = try Cards.getCard();
                                            }
                                            Cards.field[col][col].?.up = true;
                                        }
                                        for (0..Cards.stack.len) |i| {
                                            Cards.stack[i] = try Cards.getCard();
                                        }
                                    },
                                    else => unreachable,
                                }
                            },
                        }
                        self.app.menu.active = false;
                    }
                },
                else => {},
            }
            return;
        }
        // state specific events
        switch (self.app.state) {
            //Bchild state
            .Child => |*Child| switch (event) {
                .key_press => |key| {
                    // key.matches does some basic matching algorithms. Key matching can be complex in
                    // the presence of kitty keyboard encodings, this will generally be a good approach.
                    // There are other matching functions available for specific purposes, as well
                    if (!Child.clicked) {
                        if (key.matches('r', .{}))
                            Child.color.r = !Child.color.r;
                        if (key.matches('g', .{}))
                            Child.color.g = !Child.color.g;
                        if (key.matches('b', .{}))
                            Child.color.b = !Child.color.b;
                    }
                    if (key.matches('q', .{}) and (Child.state == .goodbye))
                        self.should_quit = true;
                },
                else => {},
            },
            .Tiles => |*Tiles| {
                switch (Tiles.state) {
                    .selection => {
                        switch (event) {
                            .key_press => |key| {
                                if (key.matches(vaxis.Key.enter, .{})) {
                                    enter: {
                                        if (Tiles.height == null) {
                                            Tiles.height_text = try Tiles.input.?.toOwnedSlice();
                                            Tiles.height = std.fmt.parseInt(
                                                u8,
                                                Tiles.height_text.?,
                                                10,
                                            ) catch break :enter;
                                            if ((Tiles.height.? <= 0) or (Tiles.height.? > 10)) {
                                                Tiles.height = null;
                                            }
                                        } else if (Tiles.width == null) {
                                            Tiles.width_text = try Tiles.input.?.toOwnedSlice();
                                            Tiles.width = std.fmt.parseInt(
                                                u8,
                                                Tiles.width_text.?,
                                                10,
                                            ) catch break :enter;
                                            if ((Tiles.width.? <= 0) or (Tiles.width.? > 10)) {
                                                Tiles.width = null;
                                            }

                                            // width and height inputted successfully
                                            if (Tiles.width != null) {
                                                var seed: u64 = 0;
                                                try std.posix.getrandom(std.mem.asBytes(&seed));
                                                var prng = std.rand.DefaultPrng.init(seed);
                                                const rand = prng.random();

                                                Tiles.colors =
                                                    try self.allocator.alloc([]vaxis.Color, Tiles.height.?);

                                                for (Tiles.colors.?) |*row| {
                                                    row.* = try self.allocator.alloc(vaxis.Color, Tiles.width.?);
                                                    for (row.*) |*color| {
                                                        const r = rand.int(u8);
                                                        const g = rand.int(u8);
                                                        const b = rand.int(u8);
                                                        color.* = .{ .rgb = [_]u8{ r, g, b } };
                                                    }
                                                }
                                                Tiles.state = .tiles;
                                            }
                                        }
                                    }
                                } else try Tiles.input.?.update(.{ .key_press = key });
                            },
                            else => {},
                        }

                        //Tiles.state = .tiles;
                    },
                    .tiles => {},
                }
            },
            .Battle => |*Battle| {
                switch (Battle.state) {
                    .main => |*menu| {
                        switch (event) {
                            .key_press => |key| {
                                const len = @typeInfo(BattleState).Enum.fields.len;
                                if (key.matchExact(vaxis.Key.tab, .{})) {
                                    const int = @intFromEnum(self.app.menu.state);
                                    menu.state = @enumFromInt((int + 1) % len);
                                }
                                if (key.matches(vaxis.Key.enter, .{})) {
                                    switch (menu.state) {
                                        .Attack => {
                                            Battle.state = .{ .attack = .{} };
                                        },
                                    }
                                }
                            },
                            else => {},
                        }
                    },
                    .attack => |*menu| {
                        switch (event) {
                            .key_press => |key| {
                                if (key.matchExact(vaxis.Key.tab, .{})) {
                                    menu.num = (menu.num + 1) % (Battle.len + 1);
                                }
                                if (key.matches(vaxis.Key.enter, .{})) {
                                    if (menu.num == Battle.len)
                                        Battle.state = .{ .main = .{} };
                                }
                            },
                            else => {},
                        }
                    },
                }
            },
            .Boxes => |*Boxes| {
                switch (event) {
                    .key_press => |key| {
                        if (key.matches(vaxis.Key.left, .{})) {
                            if (Boxes.shift(Boxes.pos, .{ .x = 1, .y = 0, .inv = true }))
                                Boxes.pos.x -= 1;
                        }
                        if (key.matches(vaxis.Key.right, .{})) {
                            if (Boxes.shift(Boxes.pos, .{ .x = 1, .y = 0 }))
                                Boxes.pos.x += 1;
                        }
                        if (key.matches(vaxis.Key.up, .{})) {
                            if (Boxes.shift(Boxes.pos, .{ .x = 0, .y = 1, .inv = true }))
                                Boxes.pos.y -= 1;
                        }
                        if (key.matches(vaxis.Key.down, .{})) {
                            if (Boxes.shift(Boxes.pos, .{ .x = 0, .y = 1 }))
                                Boxes.pos.y += 1;
                        }
                    },
                    else => {},
                }
            },
            .Cards => |*Cards| case: {
                if (Cards.opts.menu) {
                    switch (event) {
                        .key_press => |key| {
                            const int = @intFromEnum(Cards.opts.select);
                            const len = @typeInfo(@TypeOf(Cards.opts.select)).Enum.fields.len;
                            if (key.matches(vaxis.Key.up, .{}) and (int > 0))
                                Cards.opts.select = @enumFromInt(int - 1);
                            if (key.matches(vaxis.Key.down, .{}) and (int < len - 1))
                                Cards.opts.select = @enumFromInt(int + 1);
                            if (key.matches(vaxis.Key.enter, .{})) switch (Cards.opts.select) {
                                .symbols => Cards.opts.symbols = !Cards.opts.symbols,
                                .pull3 => Cards.opts.pull3 = !Cards.opts.pull3,
                                .start => Cards.opts.menu = false,
                            };
                        },
                        else => {},
                    }
                    break :case;
                }
                if (Cards.win) {
                    switch (event) {
                        // reset state on key press
                        .key_press => {
                            // state that is kept
                            const wins = Cards.numWins;
                            const opts = Cards.opts;
                            self.app.state = .{ .Cards = .{
                                .numWins = wins,
                                .opts = opts,
                            } };
                            // reset
                            try Cards.shuffle();
                            for (0..7) |col| {
                                for (0..(col + 1)) |row| {
                                    Cards.field[col][row] = try Cards.getCard();
                                }
                                Cards.field[col][col].?.up = true;
                            }
                            for (0..Cards.stack.len) |i| {
                                Cards.stack[i] = try Cards.getCard();
                            }
                        },
                        else => {},
                    }
                    break :case;
                }
                switch (event) {
                    .key_press => |key| {
                        // pull cards from stack
                        if (key.matches('p', .{}) and (Cards.mode == .select)) {
                            if (Cards.stack[0]) |card0| {
                                if (!card0.up) {
                                    try Cards.pullStack();
                                } else Cards.flipStack();
                            }
                        }
                        // exit move mode
                        if (key.matches(vaxis.Key.backspace, .{}) and (Cards.mode == .move)) {
                            Cards.select = .field;
                            Cards.pos = Cards.move;
                            Cards.mode = .select;
                            Cards.card = null;
                        }
                        // select the stack
                        if (key.matches('s', .{}) and (Cards.mode == .select)) {
                            // get the card on the stack
                            for (Cards.stack) |_card| {
                                if (_card) |card| {
                                    // there is a card face up
                                    if (card.up) {
                                        Cards.card = card;
                                        Cards.move = switch (Cards.select) {
                                            .field, .ace => Cards.pos,
                                            .stack => unreachable,
                                        };
                                        Cards.select = .stack;
                                        Cards.mode = .move;
                                        break;
                                    }
                                } else break;
                            }
                        }
                        // ace key
                        if (key.matches('a', .{})) {
                            switch (Cards.mode) {
                                // switch selection to and from ace piles
                                .select => Cards.select = switch (Cards.select) {
                                    .field => .{ .ace = 0 },
                                    .ace => .field,
                                    .stack => unreachable,
                                },
                                // test if card can be moved to ace piles
                                .move => {
                                    blk: {
                                        const pile = @intFromEnum(Cards.card.?.suit);
                                        // if the pile is empty
                                        if (Cards.acePiles[pile][0] == null) {
                                            if (Cards.card.?.value == .A) {
                                                Cards.acePiles[pile][0] = Cards.card;
                                                Cards.card = null;
                                            }
                                            break :blk;
                                        }
                                        // loop until iter is on a null
                                        var iter: usize = 1;
                                        while (Cards.acePiles[pile][iter]) |_| : (iter += 1) {
                                            if (iter == Cards.acePiles[pile].len - 1) break :blk;
                                        }
                                        const val: CardVal = @enumFromInt(iter);
                                        if (Cards.card.?.value == val) {
                                            Cards.acePiles[pile][iter] = Cards.card;
                                            Cards.card = null;
                                        }
                                    }
                                    // successful move
                                    if (Cards.card == null) {
                                        switch (Cards.select) {
                                            .field => {
                                                // flip card
                                                if (Cards.pos.y > 0) {
                                                    Cards.field[Cards.pos.x][Cards.pos.y - 1].?.up = true;
                                                }
                                                Cards.field[Cards.pos.x][Cards.pos.y] = null;
                                                // find a new position
                                                if ((Cards.move.x == Cards.pos.x) and (Cards.move.y == Cards.pos.y)) {
                                                    if (Cards.pos.y > 0) {
                                                        Cards.pos.x = Cards.move.x;
                                                        Cards.pos.y = Cards.move.y - 1;
                                                    }
                                                    // else we're at 0, hovering over an empty location
                                                } else Cards.pos = Cards.move;
                                            },
                                            .ace => {}, // move from ace to itself
                                            .stack => {
                                                try Cards.popStack();
                                            },
                                        }
                                        Cards.select = .field;
                                        Cards.mode = .select;
                                    }
                                    // check win!!!
                                    if ((Cards.acePiles[0][12] != null) and
                                        (Cards.acePiles[1][12] != null) and
                                        (Cards.acePiles[2][12] != null) and
                                        (Cards.acePiles[3][12] != null))
                                    {
                                        Cards.win = true; // Yippee!!!!!!!
                                        Cards.numWins += 1;
                                    }
                                },
                            }
                        }
                        if (key.matches(vaxis.Key.enter, .{})) {
                            switch (Cards.mode) {
                                .select => {
                                    switch (Cards.select) {
                                        .field => blk: {
                                            // selecting an unflipped card
                                            if (Cards.field[Cards.pos.x][Cards.pos.y]) |card| {
                                                if (card.up == false) break :blk;
                                            } else {
                                                // selecting a null card
                                                break :blk;
                                            }
                                            //trying to select a buried card
                                            for ((Cards.pos.y + 1)..Cards.field[0].len) |i| {
                                                if (Cards.field[Cards.pos.x][i]) |card| {
                                                    // buried under a king
                                                    if (card.value == .K) break :blk;
                                                    const value: CardVal = @enumFromInt(@intFromEnum(card.value) + 1);
                                                    // numbers dont match
                                                    if (Cards.field[Cards.pos.x][i - 1].?.value != value) break :blk;
                                                } else break;
                                            }
                                            Cards.card = Cards.field[Cards.pos.x][Cards.pos.y];
                                            Cards.mode = .move;
                                            Cards.move = Cards.pos;
                                        },
                                        .ace => |pile| blk: {
                                            // trying to select ace pile
                                            if (Cards.acePiles[pile][0] == null) break :blk;
                                            // loop until iter is on the first null
                                            var iter: usize = 1;
                                            while (Cards.acePiles[pile][iter]) |_| : (iter += 1) {
                                                if (iter == Cards.acePiles[pile].len - 1) {
                                                    iter += 1;
                                                    break;
                                                }
                                            }
                                            Cards.card = Cards.acePiles[pile][iter - 1];
                                            Cards.mode = .move;
                                            Cards.move = Cards.pos;
                                        },
                                        .stack => unreachable,
                                    }
                                },
                                .move => blk: {
                                    // trying to move onto the final card, must be impossible
                                    if (Cards.move.y >= Cards.field[0].len - 1)
                                        break :blk;
                                    // trying to move onto a non-empty card
                                    if (Cards.field[Cards.move.x][Cards.move.y + 1]) |_|
                                        break :blk;
                                    // moving onto an empty space
                                    if ((Cards.move.y == 0) and (Cards.field[Cards.move.x][Cards.move.y] == null)) {
                                        // not a king
                                        if (Cards.card.?.value != .K)
                                            break :blk;
                                        // correct move
                                        // move
                                        switch (Cards.select) {
                                            .field => {
                                                // flip card
                                                if (Cards.pos.y > 0)
                                                    Cards.field[Cards.pos.x][Cards.pos.y - 1].?.up = true;
                                                // move
                                                while (Cards.field[Cards.pos.x][Cards.pos.y]) |to_move| : ({
                                                    Cards.pos.y += 1;
                                                    Cards.move.y += 1;
                                                }) {
                                                    Cards.field[Cards.move.x][Cards.move.y] = to_move;
                                                    Cards.field[Cards.pos.x][Cards.pos.y] = null;
                                                }
                                                Cards.move.y -= 1;
                                            },
                                            .ace => |pile| {
                                                if (Cards.acePiles[pile][12] != null) {
                                                    Cards.field[Cards.move.x][Cards.move.y] = Cards.card;
                                                    Cards.acePiles[pile][12] = null;
                                                }
                                            },
                                            .stack => {
                                                Cards.field[Cards.move.x][Cards.move.y] = Cards.card;
                                                try Cards.popStack();
                                            },
                                        }

                                        Cards.card = null;

                                        // non empty space
                                    } else {
                                        // moving onto a card
                                        const card: Card = Cards.field[Cards.move.x][Cards.move.y].?;
                                        // trying to move onto same color
                                        switch (Cards.card.?.suit) {
                                            .club, .spade => if ((card.suit == .club) or (card.suit == .spade))
                                                break :blk,
                                            .diamond, .heart => if ((card.suit == .diamond) or (card.suit == .heart))
                                                break :blk,
                                        }
                                        // trying to move onto an ace
                                        if (card.value == .A)
                                            break :blk;
                                        // trying to move onto wrong number
                                        const value: CardVal = @enumFromInt(@intFromEnum(card.value) - 1);
                                        if (Cards.card.?.value != value)
                                            break :blk;
                                        // correct move
                                        // move
                                        switch (Cards.select) {
                                            .field => {
                                                // flip card under
                                                if (Cards.pos.y > 0)
                                                    Cards.field[Cards.pos.x][Cards.pos.y - 1].?.up = true;
                                                // move card
                                                Cards.move.y += 1;
                                                while (Cards.field[Cards.pos.x][Cards.pos.y]) |to_move| : ({
                                                    Cards.pos.y += 1;
                                                    Cards.move.y += 1;
                                                }) {
                                                    Cards.field[Cards.move.x][Cards.move.y] = to_move;
                                                    Cards.field[Cards.pos.x][Cards.pos.y] = null;
                                                }
                                                Cards.move.y -= 1;
                                            },
                                            .ace => |pile| {
                                                Cards.field[Cards.move.x][Cards.move.y + 1] = Cards.card;
                                                // set top card to null
                                                for (Cards.acePiles[pile], 0..) |_ace, i| {
                                                    if (_ace == null) {
                                                        Cards.acePiles[pile][i - 1] = null;
                                                    }
                                                }
                                            },
                                            .stack => {
                                                Cards.field[Cards.move.x][Cards.move.y + 1] = Cards.card;
                                                try Cards.popStack();
                                                Cards.move.y += 1;
                                            },
                                        }
                                        Cards.card = null;
                                    }
                                    // set state (after any successful move)
                                    Cards.select = .field;
                                    Cards.pos = Cards.move;
                                    Cards.mode = .select;
                                },
                            }
                        }
                        // movement detection
                        switch (Cards.mode) {
                            .select => {
                                switch (Cards.select) {
                                    .field => {
                                        if (key.matches(vaxis.Key.up, .{})) blk: {
                                            if (Cards.pos.y <= 0) break :blk;
                                            if ((Cards.field[Cards.pos.x][Cards.pos.y - 1] == null) and
                                                (Cards.pos.y - 1 != 0)) break :blk;
                                            Cards.pos.y -= 1;
                                        }
                                        if (key.matches(vaxis.Key.down, .{})) blk: {
                                            if (Cards.pos.y >= Cards.field[0].len - 1) break :blk;
                                            if ((Cards.field[Cards.pos.x][Cards.pos.y + 1] == null) and
                                                (Cards.pos.y + 1 != 0)) break :blk;
                                            Cards.pos.y += 1;
                                        }
                                        if (key.matches(vaxis.Key.left, .{})) blk: {
                                            if (Cards.pos.x <= 0) break :blk;
                                            if ((Cards.field[Cards.pos.x - 1][Cards.pos.y] == null) and
                                                (Cards.pos.y != 0)) break :blk;
                                            Cards.pos.x -= 1;
                                        }
                                        if (key.matches(vaxis.Key.right, .{})) blk: {
                                            if (Cards.pos.x >= Cards.field.len - 1) break :blk;
                                            if ((Cards.field[Cards.pos.x + 1][Cards.pos.y] == null) and
                                                (Cards.pos.y != 0)) break :blk;
                                            Cards.pos.x += 1;
                                        }
                                        if (key.matches('w', .{})) {
                                            Cards.win = true;
                                            Cards.numWins += 1;
                                        }
                                    },
                                    .ace => |pile| {
                                        if (key.matches(vaxis.Key.left, .{})) blk: {
                                            if (pile <= 0) break :blk;
                                            Cards.select = .{ .ace = pile - 1 };
                                        }
                                        if (key.matches(vaxis.Key.right, .{})) blk: {
                                            if (pile >= Cards.acePiles.len - 1) break :blk;
                                            Cards.select = .{ .ace = pile + 1 };
                                        }
                                    },
                                    .stack => unreachable,
                                }
                            },
                            .move => {
                                if (key.matches(vaxis.Key.up, .{})) blk: {
                                    if (Cards.move.y <= 0) break :blk;
                                    if ((Cards.field[Cards.move.x][Cards.move.y - 1] == null) and
                                        (Cards.move.y - 1 != 0)) break :blk;
                                    Cards.move.y -= 1;
                                }
                                if (key.matches(vaxis.Key.down, .{})) blk: {
                                    if (Cards.move.y >= Cards.field[0].len - 1) break :blk;
                                    if ((Cards.field[Cards.move.x][Cards.move.y + 1] == null) and
                                        (Cards.move.y + 1 != 0)) break :blk;
                                    Cards.move.y += 1;
                                }
                                if (key.matches(vaxis.Key.left, .{})) blk: {
                                    if (Cards.move.x <= 0) break :blk;
                                    if ((Cards.field[Cards.move.x - 1][Cards.move.y] == null) and
                                        (Cards.move.y != 0)) break :blk;
                                    Cards.move.x -= 1;
                                }
                                if (key.matches(vaxis.Key.right, .{})) blk: {
                                    if (Cards.move.x >= Cards.field.len - 1) break :blk;
                                    if ((Cards.field[Cards.move.x + 1][Cards.move.y] == null) and
                                        (Cards.move.y != 0)) break :blk;
                                    Cards.move.x += 1;
                                }
                            },
                        }
                    },
                    else => {},
                }
            },
        }
    }

    /// Draw our current state
    pub fn draw(self: *MyApp) void {
        var redraw: bool = false;

        // Window is a bounded area with a view to the screen. You cannot draw outside of a windows
        // bounds. They are light structures, not intended to be stored.
        const win = self.vx.window();

        // Clearing the window has the effect of setting each cell to it's "default" state. Vaxis
        // applications typically will be immediate mode, and you will redraw your entire
        // application during the draw cycle.
        win.clear();
        win.setCursorShape(.default);
        win.hideCursor();

        // In addition to clearing our window, we want to clear the mouse shape state since we may
        // be changing that as well
        self.vx.setMouseShape(.default);

        if (self.app.menu.active) {
            const states = @typeInfo(State).Enum.fields;

            const menu = win.child(.{
                .x_off = 1,
                .y_off = 1,
                .width = .{ .limit = win.width - 2 },
                .height = .{ .limit = (states.len * 2) + 1 },
            });

            const msg = "Select the app to run";
            _ = try menu.printSegment(.{ .text = msg }, .{});

            inline for (0..states.len) |i| {
                const style = vaxis.Style{
                    .reverse = (i == @intFromEnum(self.app.menu.state)),
                };
                const num = [1]u8{'1' + i};
                const text = "[" ++ num ++ "]";
                _ = try menu.printSegment(.{
                    .text = text,
                    .style = .{},
                }, .{ .row_offset = 2 * (i + 1) });
                _ = try menu.printSegment(.{
                    .text = states[i].name,
                    .style = style,
                }, .{ .row_offset = 2 * (i + 1), .col_offset = 4 });
            }
        } else switch (self.app.state) {
            .Child => |*Child| {

                // set the message
                const msg = switch (Child.state) {
                    .hello => "Hello, world!",
                    .goodbye => "Goodbye, world!",
                };

                const child_win = win.child(.{
                    .x_off = (win.width / 2) - (msg.len / 2),
                    .y_off = win.height / 2 + 1,
                    .width = .{ .limit = msg.len },
                    .height = .{ .limit = 1 },
                });

                // mouse events are much easier to handle in the draw cycle. Windows have a helper method to
                // determine if the event occurred in the target window. This method returns null if there
                // is no mouse event, or if it occurred outside of the window

                // start handling mouse events
                const unclicked = if (self.mouse) |mouse| blk: {
                    break :blk (mouse.type == .release);
                } else false;
                var unhovered = (self.mouse != null);

                // window mouse events
                if (child_win.hasMouse(self.mouse)) |mouse| {
                    // mouse shape doesnt work
                    self.vx.setMouseShape(.text);
                    Child.hovered = true;
                    unhovered = false;
                    // button logic
                    if ((mouse.button == .left)) {
                        if (Child.clicked and (mouse.type == .release)) {
                            switch (Child.state) {
                                .hello => Child.state = .goodbye,
                                .goodbye => Child.state = .hello,
                            }
                            redraw = true;
                        }
                        if (mouse.type == .press) Child.clicked = true;
                    }
                    // mouse event handled
                    self.mouse = null;
                }

                // finish handling mouse events
                if (unclicked) Child.clicked = false;
                if (unhovered) Child.hovered = false;

                // define the style of the text in child
                var style = vaxis.Style{
                    .fg = .{ .rgb = [_]u8{ 0, 0, 0 } },
                    .reverse = Child.hovered,
                };

                // change color of text
                if (Child.color.r) {
                    switch (style.fg) {
                        .rgb => |rgb| style.fg = .{ .rgb = [_]u8{ 255, rgb[1], rgb[2] } },
                        else => {},
                    }
                }
                if (Child.color.g) {
                    switch (style.fg) {
                        .rgb => |rgb| style.fg = .{ .rgb = [_]u8{ rgb[0], 255, rgb[2] } },
                        else => {},
                    }
                }
                if (Child.color.b) {
                    switch (style.fg) {
                        .rgb => |rgb| style.fg = .{ .rgb = [_]u8{ rgb[0], rgb[1], 255 } },
                        else => {},
                    }
                }

                // Print a text segment to the screen. This is a helper function which iterates over the
                // text field for graphemes. Alternatively, you can implement your own print functions and
                // use the writeCell API.
                _ = try child_win.printSegment(.{ .text = msg, .style = style }, .{});
            },

            .Tiles => |*Tiles| {
                switch (Tiles.state) {
                    .selection => {
                        const select = win.child(.{
                            .x_off = 1,
                            .y_off = 1,
                            .width = .{ .limit = win.width - 2 },
                            .height = .{ .limit = 2 },
                        });

                        const hMsg = "Input a height (1-10): ";
                        const hWin = select.child(.{
                            .x_off = hMsg.len,
                            .y_off = 0,
                            .width = .{ .limit = select.width - hMsg.len },
                            .height = .{ .limit = 1 },
                        });

                        const wMsg = "Input a width (1-10): ";
                        const wWin = select.child(.{
                            .x_off = wMsg.len,
                            .y_off = 1,
                            .width = .{ .limit = select.width - wMsg.len },
                            .height = .{ .limit = 1 },
                        });

                        _ = try select.printSegment(.{ .text = hMsg }, .{});
                        select.setCursorShape(.underline_blink);
                        select.showCursor(hMsg.len, 0);

                        // kinda backwards...it starts with no height (else)
                        //  and then goes to the if block
                        if (Tiles.height) |_| {
                            _ = try hWin.printSegment(.{ .text = Tiles.height_text.? }, .{});
                            _ = try select.printSegment(
                                .{ .text = wMsg },
                                .{ .row_offset = 1 },
                            );
                            Tiles.input.?.draw(wWin);
                        } else {
                            Tiles.input.?.draw(hWin);
                        }
                    },
                    .tiles => {
                        const height = Tiles.height.?;
                        const width = Tiles.width.?;
                        for (0..height) |h| {
                            for (0..width) |w| {
                                const cell: vaxis.Cell = .{
                                    .char = .{
                                        .grapheme = if ((w + h) % 2 == 0) "/" else "\\",
                                    },
                                    .style = .{
                                        .bg = Tiles.colors.?[h][w],
                                    },
                                };
                                for (((h * win.height) / height)..(((h + 1) * win.height) / height)) |y| {
                                    for (((w * win.width) / width)..(((w + 1) * win.width) / width)) |x| {
                                        win.writeCell(x, y, cell);
                                    }
                                }
                            }
                        }
                    },
                }
            },

            .Battle => |Battle| {
                switch (Battle.state) {
                    .main => {
                        const select = win.child(.{
                            .x_off = 1,
                            .y_off = win.height - 6,
                            .width = .{ .limit = win.width - 2 },
                            .height = .{ .limit = 5 },
                            .border = .{ .where = .all },
                        });
                        const states = @typeInfo(BattleState).Enum.fields;
                        inline for (0..states.len) |i| {
                            const style = vaxis.Style{
                                .reverse = (i == @intFromEnum(Battle.state)),
                            };
                            _ = try select.printSegment(
                                .{
                                    .text = states[i].name,
                                    .style = style,
                                },
                                .{
                                    .row_offset = 1 + ((i / 2) * 2),
                                    .col_offset = switch (i % 2) {
                                        0 => 3,
                                        else => (select.width / 2),
                                    },
                                },
                            );
                        }
                    },
                    .attack => |menu| {
                        const select = win.child(.{
                            .x_off = 1,
                            .y_off = win.height - 9,
                            .width = .{ .limit = win.width - 2 },
                            .height = .{ .limit = 8 },
                            .border = .{ .where = .all },
                        });
                        var i: u4 = 0;
                        while (Battle.attacks[i]) |attack| {
                            _ = try select.printSegment(
                                .{ .text = attack.name, .style = .{
                                    .reverse = (i == menu.num),
                                } },
                                .{
                                    .row_offset = 1 + ((i / 2) * 2),
                                    .col_offset = switch (i % 2) {
                                        0 => 3,
                                        else => (select.width / 2),
                                    },
                                },
                            );
                            i += 1;
                            if (i >= Battle.len) {
                                _ = try select.printSegment(
                                    .{ .text = "Back", .style = .{
                                        .reverse = (i == menu.num),
                                    } },
                                    .{
                                        .row_offset = select.height - 1,
                                        .col_offset = select.width - 6,
                                    },
                                );
                                break;
                            }
                        }
                    },
                }
            },
            .Boxes => |Boxes| {
                const field = win.child(.{
                    .x_off = (win.width / 2) - (Boxes.field[0].len / 2),
                    .y_off = (win.height / 2) - (Boxes.field.len / 2),
                    .width = .{ .limit = Boxes.field[0].len + 2 },
                    .height = .{ .limit = Boxes.field.len + 2 },
                    .border = .{ .where = .all },
                });
                for (Boxes.field, 0..) |row, y| {
                    for (row, 0..) |cell, x| {
                        const text = if ((x == Boxes.pos.x) and (y == Boxes.pos.y)) blk: {
                            break :blk "@";
                        } else switch (cell) {
                            .empty => " ",
                            .box => "X",
                        };
                        field.writeCell(x, y, .{ .char = .{ .grapheme = text } });
                    }
                }
            },
            .Cards => |Cards| case: {
                if (Cards.opts.menu) {
                    const fields = @typeInfo(State).Enum.fields;
                    for (0..fields.len) |i| {
                        const style = vaxis.Style{ .reverse = (i == @intFromEnum(Cards.opts.select)) };
                        var flag: bool = false;
                        const name = switch (i) {
                            0 => blk: {
                                flag = Cards.opts.symbols;
                                break :blk "Use card symbols      :";
                            },
                            1 => blk: {
                                flag = Cards.opts.pull3;
                                break :blk "Pull 3 cards at a time:";
                            },
                            // Start Game
                            2 => {
                                _ = try win.printSegment(.{
                                    .text = "[Start]",
                                    .style = style,
                                }, .{ .row_offset = 2 + (i * 2), .col_offset = 6 });
                                break;
                            },
                            else => unreachable,
                        };
                        const opt = if (flag) "On" else "Off";
                        _ = try win.printSegment(.{
                            .text = name,
                            .style = .{},
                        }, .{ .row_offset = 1 + (i * 2), .col_offset = 1 });
                        _ = try win.printSegment(.{
                            .text = opt,
                            .style = style,
                        }, .{ .row_offset = 1 + (i * 2), .col_offset = 2 + name.len });
                    }
                    break :case;
                }

                if (Cards.win) {
                    const msg = "You Won!";
                    _ = try win.printSegment(
                        .{
                            .text = msg,
                        },
                        .{ .row_offset = win.height / 2, .col_offset = (win.width / 2) - (msg.len / 2) },
                    );
                    break :case;
                }

                // print wins
                if (Cards.numWins > 0) {
                    const msg = "Consecutive Wins: ";
                    //var buf: [3]u8 = undefined;
                    //Cards.winStr = std.fmt.bufPrint(&buf, "{d}", .{Cards.numWins}) catch @panic("Win Num Panic");
                    const n = switch (Cards.numWins) {
                        0 => unreachable,
                        1 => "1",
                        2 => "2",
                        3 => "3",
                        4 => "4",
                        5 => "5",
                        6 => "6",
                        7 => "7",
                        8 => "8",
                        9 => "9",
                        else => "10+",
                    };
                    _ = try win.printSegment(
                        .{
                            .text = msg,
                            .style = .{ .reverse = true },
                        },
                        .{ .row_offset = win.height - 11, .col_offset = 1 },
                    );
                    _ = try win.printSegment(
                        .{
                            .text = n,
                            .style = .{ .reverse = true },
                        },
                        .{ .row_offset = win.height - 11, .col_offset = 1 + msg.len },
                    );
                } else {
                    // if there are no wins
                    // print the actions
                    var title: []const u8 = undefined;
                    var msgs: []const []const u8 = undefined;
                    switch (Cards.mode) {
                        .select => {
                            title = "Select Mode Actions";
                            msgs = &[_][]const u8{
                                "Use the arrow keys to move",
                                "[P]ull the top card(s) off the draw pile",
                                "[A]ccess the ace piles",
                                "[S]elect the top card of the draw pile",
                                "[Enter] Select the current card",
                            };
                        },
                        .move => {
                            title = "Move Mode Actions";
                            msgs = &[_][]const u8{
                                "Use the arrow keys to move",
                                "[A]ttempt to place the selected card on the ace piles",
                                "[Enter] Move the selected card to the current card",
                                "[Backspace] Exit move mode",
                            };
                        },
                    }
                    const offset = 11 + msgs.len;
                    _ = try win.printSegment(
                        .{
                            .text = title,
                            .style = .{ .ul_style = .single },
                        },
                        .{ .row_offset = win.height - offset, .col_offset = 1 },
                    );
                    for (0..msgs.len) |i| {
                        _ = try win.printSegment(
                            .{
                                .text = msgs[i],
                            },
                            .{ .row_offset = win.height + 1 + i - offset, .col_offset = 2 },
                        );
                    }
                }

                const getValue = struct {
                    pub fn getValue(card: Card) []const u8 {
                        return switch (card.value) {
                            .A => "A",
                            .@"2" => "2",
                            .@"3" => "3",
                            .@"4" => "4",
                            .@"5" => "5",
                            .@"6" => "6",
                            .@"7" => "7",
                            .@"8" => "8",
                            .@"9" => "9",
                            .@"10" => "10",
                            .J => "J",
                            .Q => "Q",
                            .K => "K",
                        };
                    }
                }.getValue;

                const getSuit = struct {
                    pub fn getSuit(symbols: bool, card: Card) []const u8 {
                        return if (symbols)
                            switch (card.suit) {
                                .spade => "󰣑",
                                .diamond => "󰣏",
                                .club => "󰣎",
                                .heart => "󰋑",
                            }
                        else switch (card.suit) {
                            .spade => "S",
                            .diamond => "D",
                            .club => "C",
                            .heart => "H",
                        };
                    }
                }.getSuit;

                const printEmpty = struct {
                    pub fn printEmpty(window: vaxis.Window, r: usize, c: usize, style: vaxis.Style) void {
                        _ = try window.printSegment(
                            .{
                                .text = "+──────+",
                                .style = style,
                            },
                            .{ .row_offset = r, .col_offset = c },
                        );
                        for (1..5) |d| {
                            _ = try window.printSegment(
                                .{
                                    .text = "│      │",
                                    .style = style,
                                },
                                .{ .row_offset = r + d, .col_offset = c },
                            );
                        }
                        _ = try window.printSegment(
                            .{
                                .text = "+──────+",
                                .style = style,
                            },
                            .{ .row_offset = r + 5, .col_offset = c },
                        );
                    }
                }.printEmpty;

                const printTop = struct {
                    pub fn printTop(
                        window: vaxis.Window,
                        r: usize,
                        c: usize,
                        card: Card,
                        style: vaxis.Style,
                        symbols: bool,
                    ) void {
                        const value = getValue(card);
                        const suit = getSuit(symbols, card);
                        _ = try window.printSegment(
                            .{
                                .text = "╭──────╮",
                                .style = style,
                            },
                            .{ .row_offset = r, .col_offset = c },
                        );
                        // card sides
                        _ = try window.printSegment(
                            .{
                                .text = "│      │",
                                .style = style,
                            },
                            .{ .row_offset = r + 1, .col_offset = c },
                        );
                        if (card.up) {
                            // card value
                            _ = try window.printSegment(
                                .{
                                    .text = value,
                                    .style = style,
                                },
                                .{ .row_offset = r + 1, .col_offset = c + 2 },
                            );
                            // card suit
                            _ = try window.printSegment(
                                .{
                                    .text = suit,
                                    .style = style,
                                },
                                .{ .row_offset = r + 1, .col_offset = c + 5 },
                            );
                        } else {
                            _ = try window.printSegment(
                                .{
                                    .text = "      ",
                                    .style = style,
                                },
                                .{ .row_offset = r + 1, .col_offset = c + 1 },
                            );
                        }
                    }
                }.printTop;

                const printCard = struct {
                    pub fn printCard(
                        window: vaxis.Window,
                        r: usize,
                        c: usize,
                        card: Card,
                        style: vaxis.Style,
                        symbols: bool,
                    ) void {
                        printTop(window, r, c, card, style, symbols);
                        for (2..5) |d| {
                            _ = try window.printSegment(
                                .{
                                    .text = "│      │",
                                    .style = style,
                                },
                                .{ .row_offset = r + d, .col_offset = c },
                            );
                        }
                        _ = try window.printSegment(
                            .{
                                .text = "╰──────╯",
                                .style = style,
                            },
                            .{ .row_offset = r + 5, .col_offset = c },
                        );
                    }
                }.printCard;

                const symbols = Cards.opts.symbols;

                // print the field
                for (Cards.field, 0..) |col, i| {
                    for (col, 0..) |_card, j| {
                        if (_card) |card| {
                            const style: vaxis.Style = if ((Cards.move.x == i) and (Cards.move.y == j) and
                                (Cards.mode == .move)) .{
                                .fg = .{ .rgb = [_]u8{ 255, 0, 255 } },
                            } else if ((Cards.pos.x == i) and (Cards.pos.y == j) and
                                (Cards.select == .field)) .{
                                .fg = .{ .rgb = [_]u8{ 0, 255, 255 } },
                            } else .{};
                            printTop(win, 1 + (j * 2), 1 + (i * 9), card, style, symbols);
                        } else {
                            if (j == 0) {
                                const style: vaxis.Style = if ((Cards.move.x == i) and (Cards.move.y == j) and
                                    (Cards.mode == .move)) .{
                                    .fg = .{ .rgb = [_]u8{ 255, 0, 255 } },
                                } else if ((Cards.pos.x == i) and (Cards.pos.y == j) and
                                    (Cards.select == .field)) .{
                                    .fg = .{ .rgb = [_]u8{ 0, 255, 255 } },
                                } else .{};
                                printEmpty(win, 1, 1 + (i * 9), style);
                            } else {
                                const style: vaxis.Style = if ((Cards.move.x == i) and (Cards.move.y == j - 1) and
                                    (Cards.mode == .move)) .{
                                    .fg = .{ .rgb = [_]u8{ 255, 0, 255 } },
                                } else if ((Cards.pos.x == i) and (Cards.pos.y == j - 1) and
                                    (Cards.select == .field)) .{
                                    .fg = .{ .rgb = [_]u8{ 0, 255, 255 } },
                                } else .{};
                                printCard(win, (j * 2) - 1, 1 + (i * 9), col[j - 1].?, style, symbols);
                            }
                            break;
                        }
                    }
                }

                // print the stack
                if (Cards.stack[0]) |card0| {
                    // check for fully flipped stack
                    const style: vaxis.Style = if (Cards.select == .stack) .{
                        //.reverse = true,
                        .fg = .{ .rgb = [_]u8{ 0, 255, 255 } },
                    } else .{};
                    if (card0.up) {
                        printEmpty(win, win.height - 9, 3, .{});
                        printCard(win, win.height - 9, 12, card0, style, symbols);
                    } else {
                        printCard(win, win.height - 9, 3, card0, .{}, symbols);
                        blk: {
                            var iter: usize = 1;
                            while (Cards.stack[iter]) |card| : (iter += 1) {
                                // print most recently flipped card
                                if (card.up) {
                                    printCard(win, win.height - 9, 12, card, style, symbols);
                                    break :blk;
                                }
                                if (iter == Cards.stack.len - 1) break;
                            }
                            // no cards were up
                            printEmpty(win, win.height - 9, 12, .{});
                        }
                    }
                    // loop over stack
                } else {
                    printEmpty(win, win.height - 9, 3, .{});
                    printEmpty(win, win.height - 9, 12, .{});
                }

                // print the ace piles
                for (Cards.acePiles, 0..) |pile, i| {
                    const pos = 25 + (9 * i);
                    // check for at least 1 card in pile
                    const style: vaxis.Style = switch (Cards.select) {
                        .ace => |n| if (n == i) .{
                            //.reverse = true,
                            .fg = .{ .rgb = [_]u8{ 0, 255, 255 } },
                        } else .{},
                        else => .{},
                    };
                    if (pile[0]) |_| {
                        // loop through the pile until iter is null
                        blk: {
                            var iter: usize = 1;
                            while (pile[iter]) |card| : (iter += 1) {
                                // if at the end of the pile
                                if (iter == pile.len - 1) {
                                    printCard(win, win.height - 9, pos, card, style, symbols);
                                    break :blk;
                                }
                            }
                            // iter is at null
                            printCard(win, win.height - 9, pos, pile[iter - 1].?, style, symbols);
                        }
                    } else {
                        printEmpty(win, win.height - 9, pos, style);
                    }
                }
            },
        }
        // if we need to redraw, call draw again
        if (redraw) self.draw();
    }
};

/// Keep our main function small. Typically handling arg parsing and initialization only
pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer {
        const deinit_status = gpa.deinit();
        //fail test; can't try in defer as defer is executed after we return
        if (deinit_status == .leak) {
            std.log.err("memory leak", .{});
        }
    }
    const allocator = gpa.allocator();

    // Initialize our application
    var app = try MyApp.init(allocator);
    defer app.deinit();

    // Run the application
    try app.run();
}
